<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consumption Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Added SheetJS library for Excel parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Added libraries for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 1.5rem;
        }
        .filter-button {
            background-color: #e5e7eb;
            color: #374151;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
            margin-right: 0.5rem;
            cursor: pointer;
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
        }
        .btn-primary:disabled {
            background-color: #a5b4fc;
            cursor: not-allowed;
        }
        .input-field {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
        }
        .input-field:disabled {
            background-color: #f3f4f6;
            cursor: not-allowed;
        }
        /* Styles for the loading spinner */
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #4f46e5;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div id="loading-overlay" class="overlay hidden">
        <div class="loader"></div>
    </div>

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">Consumption Analyzer</h1>
            <p class="mt-2 text-lg text-gray-600">Upload your CSV or Excel file to visualize consumption trends.</p>
        </header>

        <div class="card max-w-2xl mx-auto">
            <h2 class="text-xl font-semibold mb-4 border-b pb-2">Upload Data File</h2>
            <input type="file" id="file-input" accept=".csv,.xlsx" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/>
            
            <div id="status-message" class="mt-4 p-4 rounded-lg hidden"></div>
        </div>
        
        <div id="download-container" class="mt-8 text-center hidden">
            <button id="download-report-btn" class="btn-primary">Download Report as PDF</button>
        </div>

        <div id="chart-container" class="mt-8 card hidden">
            <h2 class="text-xl font-semibold mb-4">Monthly Consumption by Domain & Channel</h2>
            <div style="height: 400px;">
                <canvas id="consumption-chart"></canvas>
            </div>
        </div>

        <div id="yearly-chart-container" class="mt-8 card hidden">
            <h2 class="text-xl font-semibold mb-4">Yearly Consumption by Domain & Channel</h2>
            <div style="height: 400px;">
                <canvas id="yearly-consumption-chart"></canvas>
            </div>
        </div>

        <div id="filter-container" class="mt-8 card hidden">
            <h2 class="text-xl font-semibold mb-4">Filter Data</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div>
                    <h3 class="font-semibold text-gray-700 mb-2">Domains</h3>
                    <div class="mb-2">
                        <button class="filter-button" onclick="toggleAll('domains', true)">Select All</button>
                        <button class="filter-button" onclick="toggleAll('domains', false)">Deselect All</button>
                    </div>
                    <div id="domain-filters" class="space-y-1 max-h-48 overflow-y-auto pr-2"></div>
                </div>
                <div>
                    <h3 class="font-semibold text-gray-700 mb-2">Channels</h3>
                     <div class="mb-2">
                        <button class="filter-button" onclick="toggleAll('channels', true)">Select All</button>
                        <button class="filter-button" onclick="toggleAll('channels', false)">Deselect All</button>
                    </div>
                    <div id="channel-filters" class="space-y-1 max-h-48 overflow-y-auto pr-2"></div>
                </div>
            </div>
        </div>

        <div id="allotment-container" class="mt-8 card hidden">
            <h2 class="text-xl font-semibold mb-4">Analyze Consumption vs. Allotment</h2>
            <div class="space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-end">
                    <div>
                        <label for="total-allotment" class="block text-sm font-medium text-gray-700 mb-1">Total Session Allotment</label>
                        <input type="number" id="total-allotment" class="input-field" placeholder="e.g., 1000000">
                    </div>
                    <div class="flex items-center h-full pt-6">
                         <input type="checkbox" id="unlimited-allotment" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                         <label for="unlimited-allotment" class="ml-2 block text-sm text-gray-900">Unlimited Allotment</label>
                    </div>
                    <div>
                        <label for="start-date" class="block text-sm font-medium text-gray-700 mb-1">Term Start Date</label>
                        <input type="date" id="start-date" class="input-field">
                    </div>
                     <div>
                        <label for="end-date" class="block text-sm font-medium text-gray-700 mb-1">Term End Date</label>
                        <input type="date" id="end-date" class="input-field">
                    </div>
                </div>
                <div>
                    <label for="prediction-window" class="block text-sm font-medium text-gray-700 mb-1">Base Prediction On</label>
                    <select id="prediction-window" class="input-field">
                        <option value="all">All Available Data</option>
                        <option value="12">Last 12 Months</option>
                        <option value="6">Last 6 Months</option>
                        <option value="3">Last 3 Months</option>
                    </select>
                </div>
            </div>
             <button id="analyze-trends-btn" class="btn-primary w-full mt-4">Generate Trend Analysis</button>
        </div>
        
        <div id="trend-analysis-container" class="mt-8 hidden space-y-8">
            <div id="kpi-cards" class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div class="card text-center">
                    <h3 id="kpi-consumption-title" class="text-lg font-medium text-gray-500">Total Consumption</h3>
                    <p id="kpi-consumption" class="text-4xl font-bold text-indigo-600 mt-2">0%</p>
                </div>
                <div class="card text-center">
                    <h3 class="text-lg font-medium text-gray-500">Pacing</h3>
                    <p id="kpi-pacing" class="text-4xl font-bold text-blue-600 mt-2">On Track</p>
                </div>
                 <div class="card text-center">
                    <h3 id="kpi-predicted-title" class="text-lg font-medium text-gray-500">Predicted Consumption</h3>
                    <p id="kpi-predicted" class="text-4xl font-bold text-red-600 mt-2">0%</p>
                </div>
                <div class="card">
                    <h3 class="text-lg font-medium text-gray-500 text-center mb-2">Top Consumers (In Term)</h3>
                    <ul id="kpi-top-consumers-list" class="text-sm space-y-1">
                        <!-- Top consumers will be listed here -->
                    </ul>
                </div>
            </div>

            <div id="summary-container" class="card">
                <h2 class="text-xl font-semibold mb-4">Trend Analysis Summary</h2>
                <textarea id="summary-text" class="w-full h-48 p-2 border border-gray-300 rounded-md font-mono text-sm bg-gray-50" readonly></textarea>
                <button id="copy-summary-btn" class="btn-primary mt-4">Copy Summary</button>
            </div>

            <div class="card">
                <h2 class="text-xl font-semibold mb-4">Consumption Burn-Up vs. Ideal Pace</h2>
                <div style="height: 400px;">
                    <canvas id="trend-chart"></canvas>
                </div>
            </div>
        </div>

        <div id="aggregate-totals-container" class="mt-8 card hidden">
            <h2 class="text-xl font-semibold mb-4">Aggregate Totals</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div>
                    <h3 class="font-semibold text-gray-700 mb-2">Monthly Totals</h3>
                    <div class="overflow-x-auto max-h-60">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50 sticky top-0">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Month</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Total Sessions</th>
                                </tr>
                            </thead>
                            <tbody id="monthly-totals-body" class="bg-white divide-y divide-gray-200"></tbody>
                        </table>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-gray-700 mb-2">Yearly Totals</h3>
                    <div class="overflow-x-auto max-h-60">
                         <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50 sticky top-0">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Year</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Total Sessions</th>
                                </tr>
                            </thead>
                            <tbody id="yearly-totals-body" class="bg-white divide-y divide-gray-200"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>


        <div id="table-container" class="mt-8 card hidden">
            <h2 class="text-xl font-semibold mb-4">Raw File Contents</h2>
            <div class="overflow-x-auto max-h-[60vh]">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead id="table-header" class="bg-gray-50 sticky top-0"></thead>
                    <tbody id="table-body" class="bg-white divide-y divide-gray-200"></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const fileInput = document.getElementById('file-input');
        const statusMessage = document.getElementById('status-message');
        const loadingOverlay = document.getElementById('loading-overlay');
        
        const chartContainer = document.getElementById('chart-container');
        const consumptionChartCanvas = document.getElementById('consumption-chart');
        let consumptionChart = null;

        const yearlyChartContainer = document.getElementById('yearly-chart-container');
        const yearlyConsumptionChartCanvas = document.getElementById('yearly-consumption-chart');
        let yearlyConsumptionChart = null;

        const filterContainer = document.getElementById('filter-container');
        const domainFilters = document.getElementById('domain-filters');
        const channelFilters = document.getElementById('channel-filters');

        const tableContainer = document.getElementById('table-container');
        const tableHeader = document.getElementById('table-header');
        const tableBody = document.getElementById('table-body');

        const allotmentContainer = document.getElementById('allotment-container');
        const analyzeTrendsBtn = document.getElementById('analyze-trends-btn');
        const totalAllotmentInput = document.getElementById('total-allotment');
        const unlimitedAllotmentCheckbox = document.getElementById('unlimited-allotment');
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        const predictionWindowInput = document.getElementById('prediction-window');

        const trendAnalysisContainer = document.getElementById('trend-analysis-container');
        const kpiCards = document.getElementById('kpi-cards');
        const kpiConsumption = document.getElementById('kpi-consumption');
        const kpiConsumptionTitle = document.getElementById('kpi-consumption-title');
        const kpiPacing = document.getElementById('kpi-pacing');
        const kpiPredicted = document.getElementById('kpi-predicted');
        const kpiPredictedTitle = document.getElementById('kpi-predicted-title');
        const kpiTopConsumersList = document.getElementById('kpi-top-consumers-list');
        const trendChartCanvas = document.getElementById('trend-chart');
        let trendChart = null;
        
        const summaryContainer = document.getElementById('summary-container');
        const summaryText = document.getElementById('summary-text');
        const copySummaryBtn = document.getElementById('copy-summary-btn');
        
        const downloadContainer = document.getElementById('download-container');
        const downloadReportBtn = document.getElementById('download-report-btn');

        const aggregateTotalsContainer = document.getElementById('aggregate-totals-container');
        const monthlyTotalsBody = document.getElementById('monthly-totals-body');
        const yearlyTotalsBody = document.getElementById('yearly-totals-body');

        let originalData = [];

        // --- Event Listeners ---
        fileInput.addEventListener('change', handleFileSelect);
        analyzeTrendsBtn.addEventListener('click', generateTrendAnalysis);
        downloadReportBtn.addEventListener('click', downloadReport);
        copySummaryBtn.addEventListener('click', copySummary);
        unlimitedAllotmentCheckbox.addEventListener('change', (e) => {
            totalAllotmentInput.disabled = e.target.checked;
            if (e.target.checked) {
                totalAllotmentInput.value = '';
            }
        });

        // --- Main Functions ---
        function handleFileSelect(event) {
            // Reset UI
            chartContainer.classList.add('hidden');
            yearlyChartContainer.classList.add('hidden');
            tableContainer.classList.add('hidden');
            filterContainer.classList.add('hidden');
            allotmentContainer.classList.add('hidden');
            trendAnalysisContainer.classList.add('hidden');
            downloadContainer.classList.add('hidden');
            aggregateTotalsContainer.classList.add('hidden');
            statusMessage.classList.add('hidden');
            tableHeader.innerHTML = '';
            tableBody.innerHTML = '';
            if (consumptionChart) consumptionChart.destroy();
            if (yearlyConsumptionChart) yearlyConsumptionChart.destroy();
            if (trendChart) trendChart.destroy();

            const file = event.target.files[0];
            if (!file) return;

            const fileExtension = file.name.split('.').pop().toLowerCase();

            if (fileExtension === 'csv') {
                parseCsv(file);
            } else if (fileExtension === 'xlsx') {
                parseXlsx(file);
            } else {
                displayMessage('Unsupported file type. Please upload a CSV or XLSX file.', 'error');
            }
        }

        function parseCsv(file) {
             Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                transformHeader: header => header.trim().toLowerCase(), 
                complete: (results) => processParsedData(results.data, results.errors),
                error: (err) => displayMessage(`A critical error occurred: ${err.message}`, 'error')
            });
        }

        function parseXlsx(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    
                    const targetSheetName = 'Mda Sheet';
                    if (!workbook.SheetNames.includes(targetSheetName)) {
                        throw new Error(`Excel file must contain a sheet named "${targetSheetName}".`);
                    }

                    const worksheet = workbook.Sheets[targetSheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, {
                        header: 1,
                        defval: ''
                    });

                    const headers = jsonData[0].map(h => String(h).trim().toLowerCase());
                    const dataRows = jsonData.slice(1).map(row => {
                        let obj = {};
                        headers.forEach((header, index) => {
                            obj[header] = row[index];
                        });
                        return obj;
                    });

                    processParsedData(dataRows);
                } catch (err) {
                     displayMessage(`Error parsing Excel file: ${err.message}`, 'error');
                }
            };
            reader.onerror = () => displayMessage('Error reading the file.', 'error');
            reader.readAsArrayBuffer(file);
        }

        function processParsedData(data, errors = []) {
             if (errors.length) {
                displayMessage(`Error parsing file: ${errors[0].message}`, 'error');
                return;
            }

            if (!data || data.length === 0) {
                displayMessage('File is empty or could not be parsed.', 'error');
                return;
            }
            
            try {
                originalData = data;
                displayMessage(`Successfully parsed ${data.length} rows.`, 'success');
                setupFilters(originalData);
                updateChartFromFilters();
                displayTable(Object.keys(originalData[0]), originalData);
                displayAggregateTotals(originalData);
                allotmentContainer.classList.remove('hidden');
            } catch (e) {
                displayMessage(e.message, 'error');
            }
        }
        
        function setupFilters(data) {
            const domains = [...new Set(data.map(row => row.domain || 'Unknown'))].sort();
            const channels = [...new Set(data.map(row => row.channel || 'Unknown'))].sort();

            domainFilters.innerHTML = '';
            channelFilters.innerHTML = '';

            domains.forEach(domain => createFilterCheckbox(domain, 'domains', domainFilters));
            channels.forEach(channel => createFilterCheckbox(channel, 'channels', channelFilters));

            filterContainer.classList.remove('hidden');
        }

        function createFilterCheckbox(value, groupName, container) {
            const label = document.createElement('label');
            label.className = 'flex items-center space-x-2 cursor-pointer';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = groupName;
            checkbox.value = value;
            checkbox.checked = true;
            checkbox.className = 'h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500';
            checkbox.addEventListener('change', updateChartFromFilters);

            const span = document.createElement('span');
            span.textContent = value;
            span.className = 'text-sm text-gray-700';

            label.appendChild(checkbox);
            label.appendChild(span);
            container.appendChild(label);
        }

        function toggleAll(groupName, shouldBeChecked) {
            document.querySelectorAll(`input[name="${groupName}"]`).forEach(checkbox => {
                checkbox.checked = shouldBeChecked;
            });
            updateChartFromFilters();
        }

        function updateChartFromFilters() {
            const selectedDomains = Array.from(document.querySelectorAll('input[name="domains"]:checked')).map(cb => cb.value);
            const selectedChannels = Array.from(document.querySelectorAll('input[name="channels"]:checked')).map(cb => cb.value);

            const filteredData = originalData.filter(row => {
                return selectedDomains.includes(row.domain || 'Unknown') && selectedChannels.includes(row.channel || 'Unknown');
            });

            displayConsumptionChart(filteredData);
            displayYearlyConsumptionChart(filteredData);
        }

        function displayConsumptionChart(data) {
            const requiredCols = ['month', 'domain', 'channel', 'count'];
            if (originalData.length > 0 && !requiredCols.every(col => originalData[0].hasOwnProperty(col))) {
                throw new Error(`The CSV file is missing required columns. Please ensure it has: ${requiredCols.join(', ')}.`);
            }

            const monthlyData = {};
            const datasetKeys = new Set();

            data.forEach(row => {
                const date = parseMDYDate(row.month);
                if (!date) return;
                const monthKey = date.toISOString().slice(0, 7);
                const count = Number(String(row.count).replace(/,/g, '')) || 0;
                const dataKey = `${row.domain || 'Unknown'} - ${row.channel || 'Unknown'}`;
                datasetKeys.add(dataKey);
                if (!monthlyData[monthKey]) monthlyData[monthKey] = {};
                if (!monthlyData[monthKey][dataKey]) monthlyData[monthKey][dataKey] = 0;
                monthlyData[monthKey][dataKey] += count;
            });

            const sortedMonths = [...new Set(originalData.map(r => parseMDYDate(r.month)).filter(Boolean).map(d => d.toISOString().slice(0, 7)))].sort();
            const sortedDatasetKeys = Array.from(datasetKeys).sort();

            const datasets = sortedDatasetKeys.map((key, index) => ({
                label: key,
                data: sortedMonths.map(month => monthlyData[month]?.[key] || 0),
                borderColor: generateColor(index),
                backgroundColor: generateColor(index) + '1A',
                fill: true,
                tension: 0.2,
                borderWidth: 2
            }));

            if (consumptionChart) consumptionChart.destroy();
            consumptionChart = new Chart(consumptionChartCanvas, {
                type: 'line',
                data: { labels: sortedMonths, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false, // Disable animation for clean PDF capture
                    scales: {
                        x: { type: 'time', time: { unit: 'month' }, title: { display: true, text: 'Month' } },
                        y: { beginAtZero: true, title: { display: true, text: 'Total Sessions' } }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            filter: (item) => item.raw > 0,
                            itemSort: (a, b) => b.raw - a.raw
                        }
                    }
                }
            });
            chartContainer.classList.remove('hidden');
        }

        function displayYearlyConsumptionChart(data) {
            const yearlyData = {};
            const datasetKeys = new Set();
            data.forEach(row => {
                const date = parseMDYDate(row.month);
                if (!date) return;
                const yearKey = date.getUTCFullYear();
                const count = Number(String(row.count).replace(/,/g, '')) || 0;
                const dataKey = `${row.domain || 'Unknown'} - ${row.channel || 'Unknown'}`;
                datasetKeys.add(dataKey);
                if (!yearlyData[yearKey]) yearlyData[yearKey] = {};
                if (!yearlyData[yearKey][dataKey]) yearlyData[yearKey][dataKey] = 0;
                yearlyData[yearKey][dataKey] += count;
            });

            const sortedYears = [...new Set(originalData.map(r => parseMDYDate(r.month)).filter(Boolean).map(d => d.getUTCFullYear()))].sort();
            const sortedDatasetKeys = Array.from(datasetKeys).sort();
            const datasets = sortedDatasetKeys.map((key, index) => ({
                label: key,
                data: sortedYears.map(year => yearlyData[year]?.[key] || 0),
                borderColor: generateColor(index),
                backgroundColor: generateColor(index) + '1A',
                fill: true,
                tension: 0.2,
                borderWidth: 2
            }));

            if (yearlyConsumptionChart) yearlyConsumptionChart.destroy();
            yearlyConsumptionChart = new Chart(yearlyConsumptionChartCanvas, {
                type: 'line',
                data: { labels: sortedYears.map(year => new Date(year, 0, 1)), datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false, // Disable animation for clean PDF capture
                    scales: {
                        x: { type: 'time', time: { unit: 'year' }, title: { display: true, text: 'Year' } },
                        y: { beginAtZero: true, title: { display: true, text: 'Total Sessions' } }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            filter: (item) => item.raw > 0,
                            itemSort: (a, b) => b.raw - a.raw
                        }
                    }
                }
            });
            yearlyChartContainer.classList.remove('hidden');
        }
        
        function generateTrendAnalysis() {
            try {
                const isUnlimited = unlimitedAllotmentCheckbox.checked;
                const totalAllotment = isUnlimited ? Infinity : parseFloat(totalAllotmentInput.value);
                const startDate = new Date(startDateInput.value + 'T00:00:00Z');
                const endDate = new Date(endDateInput.value + 'T00:00:00Z');
                const predictionWindow = predictionWindowInput.value;

                if (!isUnlimited && (isNaN(totalAllotment) || totalAllotment <= 0)) throw new Error("Invalid Total Allotment value.");
                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) throw new Error("Invalid start or end date.");
                if (endDate <= startDate) throw new Error("End date must be after start date.");

                // --- DATA PREPARATION ---
                const selectedDomains = Array.from(document.querySelectorAll('input[name="domains"]:checked')).map(cb => cb.value);
                const selectedChannels = Array.from(document.querySelectorAll('input[name="channels"]:checked')).map(cb => cb.value);
                const dataForAnalysis = originalData.filter(row => {
                    return selectedDomains.includes(row.domain || 'Unknown') && selectedChannels.includes(row.channel || 'Unknown');
                });

                const monthlyDataMap = new Map();
                let totalConsumedInTerm = 0;
                const topConsumersMap = new Map();

                const termData = dataForAnalysis.filter(row => {
                    const date = parseMDYDate(row.month);
                    return date && date >= startDate && date <= endDate;
                });

                termData.forEach(row => {
                    const date = parseMDYDate(row.month);
                    if (!date) return;
                    const count = Number(String(row.count).replace(/,/g, '')) || 0;
                    totalConsumedInTerm += count;
                    const monthKey = date.toISOString().slice(0, 7);
                    const currentMonthTotal = (monthlyDataMap.get(monthKey) || 0) + count;
                    monthlyDataMap.set(monthKey, currentMonthTotal);

                    const consumerKey = `${row.domain || 'Unknown'} - ${row.channel || 'Unknown'}`;
                    const currentConsumerTotal = (topConsumersMap.get(consumerKey) || 0) + count;
                    topConsumersMap.set(consumerKey, currentConsumerTotal);
                });

                const cumulativeSumMap = new Map();
                let cumulativeSum = 0;
                const sortedMonthsInData = Array.from(monthlyDataMap.keys()).sort();
                sortedMonthsInData.forEach(monthKey => {
                    cumulativeSum += monthlyDataMap.get(monthKey);
                    cumulativeSumMap.set(monthKey, cumulativeSum);
                });

                // --- CHART DATA GENERATION ---
                const termStart = new Date(Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), 1));
                const termEnd = new Date(Date.UTC(endDate.getUTCFullYear(), endDate.getUTCMonth(), 1));
                
                const fullTermLabels = [];
                let currentMonth = new Date(termStart);
                while (currentMonth <= termEnd) {
                    fullTermLabels.push(currentMonth.toISOString().slice(0, 7));
                    currentMonth.setUTCMonth(currentMonth.getUTCMonth() + 1);
                }

                const lastDataMonth = sortedMonthsInData[sortedMonthsInData.length - 1];
                const actualConsumptionData = fullTermLabels.map(monthKey => {
                    if (monthKey > lastDataMonth) return null;
                    return cumulativeSumMap.get(monthKey);
                });

                // --- PREDICTION & IDEAL PACE LOGIC ---
                let predictedConsumptionData = [];
                let predictedConsumptionFinal = 0;
                let idealLineData = [];
                let predictionBasisText = "all available data";

                if (sortedMonthsInData.length > 0) {
                    let monthsForPrediction = sortedMonthsInData;
                    if (predictionWindow !== 'all') {
                        const windowSize = parseInt(predictionWindow);
                        monthsForPrediction = sortedMonthsInData.slice(-windowSize);
                        predictionBasisText = `the last ${monthsForPrediction.length} months`;
                    }
                    const predictionPeriodConsumption = monthsForPrediction.reduce((sum, monthKey) => sum + monthlyDataMap.get(monthKey), 0);
                    const averageMonthlyConsumption = predictionPeriodConsumption / monthsForPrediction.length;
                    const lastCumulativeValue = cumulativeSumMap.get(lastDataMonth);
                    const lastDataIndex = fullTermLabels.indexOf(lastDataMonth);
                    predictedConsumptionData = new Array(fullTermLabels.length).fill(null);
                    predictedConsumptionData[lastDataIndex] = lastCumulativeValue;
                    for (let i = lastDataIndex + 1; i < fullTermLabels.length; i++) {
                        predictedConsumptionData[i] = predictedConsumptionData[i-1] + averageMonthlyConsumption;
                    }
                    predictedConsumptionFinal = predictedConsumptionData[predictedConsumptionData.length - 1];
                }
                
                // --- KPI & SUMMARY UPDATE ---
                let summary;
                if (isUnlimited) {
                    kpiConsumptionTitle.textContent = "Total Sessions Consumed";
                    kpiPredictedTitle.textContent = "Predicted Total Sessions";
                    kpiConsumption.textContent = totalConsumedInTerm.toLocaleString();
                    kpiPacing.textContent = "Unlimited";
                    kpiPredicted.textContent = Math.round(predictedConsumptionFinal).toLocaleString();
                    summary = `
Consumption Analysis Report (Unlimited)
---------------------------------------
Term Period: ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}
Total Allotment: Unlimited

Analysis based on data within the term:
- Total Consumed: ${totalConsumedInTerm.toLocaleString()} sessions
- Predicted Consumption (based on ${predictionBasisText}): On track to consume ${Math.round(predictedConsumptionFinal).toLocaleString()} sessions by the end of the term.
                    `;
                } else {
                    kpiConsumptionTitle.textContent = "Total Consumption";
                    kpiPredictedTitle.textContent = "Predicted Consumption";
                    const consumptionPercent = (totalConsumedInTerm / totalAllotment) * 100;
                    const predictedConsumptionPercent = (predictedConsumptionFinal / totalAllotment) * 100;
                    const pacingStatus = getPacingStatus(predictedConsumptionPercent);
                    kpiConsumption.textContent = `${consumptionPercent.toFixed(1)}%`;
                    kpiPacing.textContent = pacingStatus;
                    kpiPredicted.textContent = `${predictedConsumptionPercent.toFixed(1)}%`;
                    if (pacingStatus === 'Ahead') kpiPacing.classList.add('text-red-600');
                    else if (pacingStatus === 'Behind') kpiPacing.classList.add('text-yellow-500');
                    else kpiPacing.classList.add('text-blue-600');
                    
                    const termDurationDays = (endDate - startDate) / (1000 * 60 * 60 * 24);
                    const idealRatePerDay = termDurationDays > 0 ? totalAllotment / termDurationDays : 0;
                    idealLineData = fullTermLabels.map(monthKey => {
                        const pointDate = new Date(monthKey + '-02T00:00:00Z');
                        const daysFromStart = (pointDate - startDate) / (1000 * 60 * 60 * 24);
                        return Math.max(0, idealRatePerDay * (daysFromStart + 1));
                    });
                    summary = `
Consumption Analysis Report
---------------------------
Term Period: ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}
Total Allotment: ${totalAllotment.toLocaleString()} sessions

Analysis based on data within the term:
- Total Consumed: ${totalConsumedInTerm.toLocaleString()} sessions
- Consumption Level: ${consumptionPercent.toFixed(1)}% of total allotment.
- Current Pacing: ${pacingStatus}.
- Predicted Consumption (based on ${predictionBasisText}): On track to consume ${predictedConsumptionPercent.toFixed(1)}% of the total allotment by the end of the term.
                    `;
                }
                summaryText.value = summary.trim();

                const topConsumers = Array.from(topConsumersMap.entries()).sort((a, b) => b[1] - a[1]).slice(0, 3);
                kpiTopConsumersList.innerHTML = topConsumers.map(item => `<li class="flex justify-between"><span class="truncate pr-2">${item[0]}</span><span class="font-semibold">${item[1].toLocaleString()}</span></li>`).join('');

                // --- CHART RENDERING ---
                const trendDatasets = [{
                    label: 'Actual Cumulative Consumption',
                    data: actualConsumptionData,
                    borderColor: '#4f46e5',
                    backgroundColor: 'rgba(79, 70, 229, 0.1)',
                    fill: true, tension: 0.1, spanGaps: true,
                }, {
                    label: 'Predicted Consumption',
                    data: predictedConsumptionData,
                    borderColor: '#ef4444',
                    borderDash: [10, 5],
                    fill: false, tension: 0.1,
                }];
                if (!isUnlimited) {
                    trendDatasets.splice(1, 0, {
                        label: 'Ideal Consumption Pace',
                        data: idealLineData,
                        borderColor: '#10b981',
                        borderDash: [5, 5],
                        fill: false, tension: 0.1,
                    });
                }

                if (trendChart) trendChart.destroy();
                trendChart = new Chart(trendChartCanvas, {
                    type: 'line',
                    data: { labels: fullTermLabels, datasets: trendDatasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        scales: {
                            x: { type: 'time', time: { unit: 'month' }, title: { display: true, text: 'Date' } },
                            y: { beginAtZero: true, title: { display: true, text: 'Cumulative Sessions' } }
                        },
                        plugins: { legend: { position: 'top' }, tooltip: { mode: 'index', intersect: false } }
                    }
                });

                trendAnalysisContainer.classList.remove('hidden');
                downloadContainer.classList.remove('hidden');

            } catch (e) {
                displayMessage(e.message, 'error');
            }
        }
        
        async function downloadReport() {
            loadingOverlay.classList.remove('hidden');
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'p',
                unit: 'mm',
                format: 'a4'
            });

            const addImageToPdf = async (element, doc, yPos, title) => {
                const canvas = await html2canvas(element, { 
                    scale: 2,
                    backgroundColor: '#ffffff'
                });
                const imgData = canvas.toDataURL('image/png');
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const margin = 15;
                const imgWidth = pageWidth - (margin * 2);
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                const titleHeight = 10;
                
                if (yPos + imgHeight + titleHeight > pageHeight - margin) {
                    doc.addPage();
                    yPos = margin;
                }
                
                doc.setFontSize(16);
                doc.text(title, margin, yPos);
                yPos += titleHeight;
                doc.addImage(imgData, 'PNG', margin, yPos, imgWidth, imgHeight);
                return yPos + imgHeight + 5; // Return new Y position with padding
            };

            try {
                doc.setFontSize(22);
                doc.text('Consumption Analysis Report', 105, 140, { align: 'center' });
                doc.setFontSize(12);
                doc.text(`Generated on: ${new Date().toLocaleDateString()}`, 105, 150, { align: 'center' });

                let yPos = 15;

                if (trendAnalysisContainer.offsetParent !== null) {
                    doc.addPage();
                    yPos = await addImageToPdf(kpiCards, doc, yPos, 'Key Performance Indicators');
                    yPos = await addImageToPdf(trendChartCanvas, doc, yPos, 'Consumption Burn-Up vs. Ideal Pace');
                }
                if (chartContainer.offsetParent !== null) {
                    yPos = await addImageToPdf(consumptionChartCanvas, doc, yPos, 'Monthly Consumption');
                }
                if (yearlyChartContainer.offsetParent !== null) {
                    yPos = await addImageToPdf(yearlyConsumptionChartCanvas, doc, yPos, 'Yearly Consumption');
                }
                if (aggregateTotalsContainer.offsetParent !== null) {
                    yPos = await addImageToPdf(aggregateTotalsContainer, doc, yPos, 'Aggregate Totals');
                }
                
                doc.deletePage(1);
                doc.save('Consumption_Report.pdf');

            } catch (error) {
                console.error("Error generating PDF:", error);
                displayMessage('Failed to generate PDF report.', 'error');
            } finally {
                 loadingOverlay.classList.add('hidden');
            }
        }

        function copySummary() {
            summaryText.select();
            document.execCommand('copy');
            
            const originalText = copySummaryBtn.textContent;
            copySummaryBtn.textContent = 'Copied!';
            setTimeout(() => {
                copySummaryBtn.textContent = originalText;
            }, 2000);
        }

        // --- Utility Functions ---
        function displayMessage(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = `mt-4 p-4 rounded-lg ${type === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`;
            statusMessage.classList.remove('hidden');
        }
        
        function parseMDYDate(dateString) {
            if (!dateString || typeof dateString !== 'string') return null;
            const parts = dateString.split('/');
            if (parts.length !== 3) return null;
            const month = parseInt(parts[0], 10);
            const day = parseInt(parts[1], 10);
            const year = parseInt(parts[2], 10);
            if (isNaN(month) || isNaN(day) || isNaN(year) || year < 1000 || year > 3000) return null;
            const date = new Date(Date.UTC(year, month - 1, day));
            if (date.getUTCFullYear() === year && date.getUTCMonth() === month - 1 && date.getUTCDate() === day) {
                return date;
            }
            return null;
        }
        
        function generateColor(index) {
            const colors = [
                '#4f46e5', '#10b981', '#f59e0b', '#ef4444', '#3b82f6', '#8b5cf6', '#ec4899',
                '#6366f1', '#22c55e', '#d97706', '#dc2626', '#2563eb', '#7c3aed', '#db2777',
                '#06b6d4', '#f97316', '#84cc16', '#e11d48', '#14b8a6', '#f43f5e', '#a855f7'
            ];
            return colors[index % colors.length];
        }

        function getPacingStatus(predictedPercent) {
            if (predictedPercent > 110) return "Ahead";
            if (predictedPercent < 90) return "Behind";
            return "On Track";
        }

        function displayTable(headers, data) {
            const headerRow = document.createElement('tr');
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.scope = 'col';
                th.className = 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider';
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            tableHeader.appendChild(headerRow);

            data.forEach(row => {
                const tr = document.createElement('tr');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-700';
                    td.textContent = row[header];
                    tr.appendChild(td);
                });
                tableBody.appendChild(tr);
            });
            tableContainer.classList.remove('hidden');
        }

        function displayAggregateTotals(data) {
            const monthlyTotals = {};
            const yearlyTotals = {};

            data.forEach(row => {
                const date = parseMDYDate(row.month);
                if (date) {
                    const count = Number(String(row.count).replace(/,/g, '')) || 0;
                    const monthKey = date.toISOString().slice(0, 7);
                    const yearKey = date.getUTCFullYear();
                    monthlyTotals[monthKey] = (monthlyTotals[monthKey] || 0) + count;
                    yearlyTotals[yearKey] = (yearlyTotals[yearKey] || 0) + count;
                }
            });

            monthlyTotalsBody.innerHTML = '';
            Object.keys(monthlyTotals).sort().forEach(month => {
                const row = `<tr>
                    <td class="px-4 py-2 text-sm text-gray-700">${month}</td>
                    <td class="px-4 py-2 text-sm text-gray-700">${monthlyTotals[month].toLocaleString()}</td>
                </tr>`;
                monthlyTotalsBody.innerHTML += row;
            });

            yearlyTotalsBody.innerHTML = '';
            Object.keys(yearlyTotals).sort().forEach(year => {
                const row = `<tr>
                    <td class="px-4 py-2 text-sm text-gray-700">${year}</td>
                    <td class="px-4 py-2 text-sm text-gray-700">${yearlyTotals[year].toLocaleString()}</td>
                </tr>`;
                yearlyTotalsBody.innerHTML += row;
            });

            aggregateTotalsContainer.classList.remove('hidden');
        }
    </script>
</body>
</html>
